What we’re adding

Backfill if everything is empty
If all five category calls return no tags, add the top-1 prototype tag only if its score ≥ that tag’s calibrated threshold.

Agreement-bonus guard
Only apply the ensemble agreement bonus when the prototype score ≥ (threshold − 0.03).

No new caps, no shortlist, no arbiter changes.

Where to implement

Add this in ensemble_scorer.py (inside the method that merges reasoning + prototype). If you have a method like combine(...), patch it; if not, create one and call it from your suggest flow.

Assumptions

reasoning_suggestions: list of dicts {"label_id", "category", "confidence", "rationale"} (from Step 1).

prototype_suggestions: list of dicts {"label_id", "score", "threshold"} (from your prototype scorer).

Config already has reasoning_weight, prototype_weight, agreement_bonus.

Margin is a small constant: PROTOTYPE_THRESHOLD_MARGIN = 0.03.

Code: combiner with backfill + guarded bonus
# ensemble_scorer.py

from typing import Dict, List, Any
from dataclasses import dataclass

PROTOTYPE_THRESHOLD_MARGIN = 0.03  # bonus only if proto >= (threshold - margin)

@dataclass
class EnsembleConfig:
    reasoning_weight: float = 0.8
    prototype_weight: float = 0.2
    agreement_bonus: float = 0.15   # added then clamped to 1.0

def _index_by_label(items: List[Dict[str, Any]], score_key: str) -> Dict[str, Dict[str, Any]]:
    out = {}
    for it in items:
        lid = it.get("label_id") or it.get("tag_id")
        if not lid:
            continue
        it = dict(it)
        it["label_id"] = lid
        it["score"] = float(it.get(score_key, it.get("score", 0.0)))
        out[lid] = it
    return out

def combine_reasoning_and_prototype(
    reasoning_suggestions: List[Dict[str, Any]],
    prototype_suggestions: List[Dict[str, Any]],
    cfg: EnsembleConfig,
) -> List[Dict[str, Any]]:
    """
    Returns a list of: {
      label_id, category?, reasoning_score, prototype_score, combined_score,
      agreement_bonus_applied (bool), reasons[], rationale?
    }
    No K caps, no global filtering. Sorted desc by combined_score.
    """

    # 1) index inputs
    rmap = _index_by_label(reasoning_suggestions, score_key="confidence")
    pmap = _index_by_label(prototype_suggestions,  score_key="score")

    # 2) union of all labels mentioned
    labels = set(rmap.keys()) | set(pmap.keys())

    # 3) If EVERYTHING is empty → backfill top-1 prototype above its threshold
    if not labels:
        # pick highest proto that is >= its own threshold
        eligible = [p for p in prototype_suggestions if float(p.get("score", 0.0)) >= float(p.get("threshold", 1.0))]
        if eligible:
            best = max(eligible, key=lambda x: float(x["score"]))
            # synthesize a minimal reasoning-like entry with zero reasoning score
            rmap[best["label_id"]] = {
                "label_id": best["label_id"],
                "score": 0.0,  # reasoning_score
                "category": best.get("category"),
                "rationale": "backfill: prototype top-1",
                "reasons": ["backfill_prototype"]
            }
            pmap[best["label_id"]] = {
                **best,
                "label_id": best["label_id"],
                "score": float(best["score"]),
                "threshold": float(best.get("threshold", 1.0))
            }
            labels = {best["label_id"]}

    # 4) combine
    combined: List[Dict[str, Any]] = []
    for lid in labels:
        r = rmap.get(lid)
        p = pmap.get(lid)

        reasoning_score  = float(r["score"]) if r else 0.0
        prototype_score  = float(p["score"]) if p else 0.0
        proto_threshold  = float(p.get("threshold", 1.0)) if p else 1.0

        base = (cfg.reasoning_weight * reasoning_score) + (cfg.prototype_weight * prototype_score)

        # Guarded agreement bonus
        agreement = False
        if r and p:
            if prototype_score >= (proto_threshold - PROTOTYPE_THRESHOLD_MARGIN):
                base += cfg.agreement_bonus
                agreement = True

        # clamp
        combined_score = min(1.0, max(0.0, base))

        combined.append({
            "label_id": lid,
            "category": r.get("category") if r else p.get("category") if p else None,
            "reasoning_score": reasoning_score,
            "prototype_score": prototype_score,
            "prototype_threshold": proto_threshold,
            "combined_score": combined_score,
            "agreement_bonus_applied": agreement,
            "reasons": list(set((r.get("reasons", []) if r else []) + (p.get("reasons", []) if p else []))),
            "rationale": r.get("rationale") if r else None,
            "source": "ensemble"
        })

    # 5) sort desc, no caps
    combined.sort(key=lambda x: x["combined_score"], reverse=True)
    return combined

Where to call it

In your suggest flow (after Step-1 per-category calls and prototype scoring):

# 1) build reasoning_suggestions from category_reasoning results (Step 1)
#    expected fields per item: label_id, confidence, category, rationale, reasons=["per_category_reasoning"]

# 2) ensure prototype_suggestions include thresholds
#    fields per item: label_id, score, threshold, category?, reasons? (optional)

from ensemble_scorer import combine_reasoning_and_prototype, EnsembleConfig

cfg = EnsembleConfig(
    reasoning_weight=0.8,     # keep your current values
    prototype_weight=0.2,
    agreement_bonus=0.15
)

final_suggestions = combine_reasoning_and_prototype(
    reasoning_suggestions=reasoning_suggestions,
    prototype_suggestions=prototype_suggestions,
    cfg=cfg
)

# return final_suggestions as your API response (or map to your response schema)

Minimal logging to add (so you can verify Step 2 works)

Log per lecture:

backfill_triggered: true/false (i.e., union was empty and we added top-1 proto)

count of agreement_bonus_applied items

top-3 (label_id, reasoning_score, prototype_score, prototype_threshold, combined_score)

This is enough to sanity-check behavior without extra dashboards.